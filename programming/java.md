Основи ООп
Класи
Абстрактні класи
Інтерфейси
static

---
### Різниця між фреймворком та бібліотекою

**Бібліотека** - набір фенкцій, які ви можете визивати. Бібліотеки організовані в класи. Після виклику бібліотеки, виконується якась робота і контроль повертається до користувача.

**Фреймворк** містить в собі деякий абстрактний дизайн і вбудовану поведінку. Щоб його використовувати, треба розмістити свій код в різних місцях фреймворку (через наслідування, або оддавання своїх класів). Код фреймворку буде викликати ваш код.

Основна різниця між фреймворком та бібліотекою - інверсія управління.

---

override / overload

Collections

---
### Iterator
**Iterator** - деяка сутність, здатна перебрати всі елементи колекції без вникання у її внутрішню структуру.
```
Iterator iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```


---
### Compatator vs Сomparable
Compatator і Сomparable - інтерфейси, що імплементують методи для порівняння об'єктів одного типу. 

**Comparable** реалізує всього один метод `compareTo
()`, який повертає нуль, якщо об'єкти рівні, додатнє число, якщо перший об'єкт більший за другий, та від'ємне якщо навпаки. Comparable використовується для порівняння об'єктів класу в рамках якого був реалізований.

**Comparator** імплементує кілька методів, ключовим серед яких є `compare`. Comparator
 можна використовувати з різними класами і багатократно. Від дозволяє створювати об'єкти, що керуватимуть процесом порівняння, наприклад при сортуванні.

---
### Generic
**Generic** (узагальнення) - це параметризовані типи. З їх допомогою можна оголошувати класи інтерфейси та методи, де тип даних вказаний як параметр. Даний підхід до опису даних і алгоритмів дозволяє працювати з різними типами без зміни опису (алгоритмів і даних). Дозволяє виправити помилки пов'язані з неправильним приведенням типів ще на етапі компіляції.

---

exceptions

---
### Серіалізація
**Серіалізація** - збереження стану об'єкту, наприклад для передачі по мережі чи збереження з можливістю відтворити пізніше. При серіалізації зберігаєтся повний граф об'єкта, включно зі всіма об'єктами, на які він посилається. Для того щоб бути серіалізованим, об'єкт повинен імплементувати інтерфейс `Serializable`. Для коректної серіалізації, всі об'єктина які посилається об'єкт також повинні бути `Serializable`. 

Для того, щоб серіалізувати об'єкт, потрібно створити потік `FileOutputStream`,  з'єднати його з потоком `ObjectOutputStream` та викликати з нього метод `writeObject(object)`.

Якщо змінну не треба серіалізувти (наприклад щоб не зберігати пароль), її необхідно помітити як `transient`. При десеріалізації `transient` змінна отримає значення `null`.
```
class <CLASS_NAME> implements Serializable {transient String <VAR_NAME>}
```
Статичні змінні не серіалізуються.

---

Patterns
Singletone
Factory
Page Object
Builder



java 8
default functions
default interfaces
stream API
Optionals


LOMBOK

внутр класи (стат, не стат, локал, анонімні) (якщо по логіці є в'язка батьківського класу і нащадка)
внутр стат клас може існувати без батьківського
внутр не стат не існує без батьківського
внутр локал класи метод послужив родоначальником анонімного класу. 
анонімний клас. створюється через імплементацію інтерфейсу, або наслідування



double brace ініціалазація - визначення об'єкту в момент створення

### Nested classes