## Interfaces
### Default methods
Метод за замовчуванням (default method) - не статичний метод з реалізацією оголошеною в тілі інтерфейсу. Для оголошення використовується ключове слово `default`. 
* Якщо клас імплементує інтерфейс, він може, але не зобов'язаний імплементувати дефолтні методи, клас наслідує реалізацію за замовчуванням. Якщо клас перевизначає метод, то береться імплементація з класу, якщо ні то з інтерфейсу.
* Використовується якщо потрібно розширити існуючі інтерфейси новими методами, або розширити функціональність не порушуючи зворотню сумісність.
* Інтерфейси при наслідуванні один-одного можуть перевизначати дефолтні методи.
* Якщо клас імплементує одночасно два інтерфейси з онаковими дефолтними методами, виникає проблема множинного наслідування. Якщо ж клас імплементує інтерфейс, і наслідує інший клас, в яких є однакові методи, перевага надається методу класу.

Логічним розвитком дефолтних методів є `private methods` в java 1.9. У них описуються блоки коду, які не бажано розміщувати в дефолтних методах (приховування логіки), і які не потрібні в інтерфейсах і класах, які будуть реалізувати інтерфейс. Приватні методи не наслідуються.

---
## Functional interfaces

**Функціональний інтерфейс** - інтерфейс в якого є тільки один абстрактний метод. Крім єдиного абстрактного методу може також містити `static` методи, `default` методи, та методи класу Object. Основне призначення - використання в лямбда виразах. Також функціональні інтерфейси реалізують аналог **функцій вищого порядку (функцій, які в якості аргументів можуть приймати інші функції)**.

Щоб перевірити, чи є інтерфейс функціональним на етапі компіляції, використовується анотація `@FunctionalInterface`

**Посилання на методи**  в Java 1.8 з'явився механізм, що дозволяє посилатися на метод в реалізації функціонального інтерфейсу. Для цього був введений новий оператор `::`.

#### Базові функціональні інтерфейси
* **Predicate\<T>** - приймає об'єкт типу Т і перевіряє деяку умову. Якщо умова виконується, повертає `true`.
* **Consumer\<T>** - приймає об'єкт типу Т, виконує деяку дію, але при цьому нічого не повертає.
* **Function\<T,R>** - приймає об'єкт типу Т, перетворює його на об'єкти типу R, і повертає об'єкт типу R.
* **Supplier\<T>** - не приймає жодних аргументів, але при цьому повертає об'єктитипу Т.
* **UnaryOperator\<T>** - приймає об'єкт типу Т, виконує над тим деякі операції, і повертає об'єкт того ж типу.
* **BinaryOperator\<T>** - приймає як параметри 2 об'єкти типу Т, виконує над ними деякі операції, і повертає об'єкт типу Т.
---

### Predicate
**Predicate\<T>** - функціональний інтерфейс, що з'явився у java 8. Використовується для перевірки тої чи іншої умови. Найчастіше використовується для фільтрації даних, щоб визначити, підійде об'єкт для подальшої роботи, чи ні.

Predicate містить наступні методи:
* абстрактний `boolean test(t t)`
* default `and(), or(), negate()`
* static `not(), isEqual()`

```
        List<Integer> listInt = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

        Predicate<Integer> p1 = e -> e > 2;
        Predicate<Integer> p2 = e -> e < 5;

        listInt.removeIf(p1.and(p2).negate());
        
        System.out.println(listInt); // [3, 4]
```

---


