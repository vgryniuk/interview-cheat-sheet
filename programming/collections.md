# Java Collections Framework

![Java Collections Framework diagram](java-collections-cheat-sheet.png "Java Collections Framework diagram")

---
## List
**List** є одним із основних інтерфейсів для роботи зі списками. List розширює інтерфейс `Collection`, додаючи нові методи, які дозволяють додавати та видаляти елементи за індексом, відстежувати кількість елементів у списку, знаходити індекс елемента, тощо.

* `add(int index, E element)`: додає елемент у заданий індекс у списку
* `remove(int index)`: видаляє елемент за вказаним індексом зі списку
* `get(int index)`: повертає елемент за вказаним індексом
* `set(int index, E element)`: змінює елемент за вказаним індексом
* `indexOf(Object o)`: повертає індекс першого входження елемента в списку

Інтерфейс List може бути реалізований за допомогою різних класів, таких як `ArrayList`, `LinkedList`, `Vector` тощо. 

**ArrayList** - клас, що дозволяє зберігати дані різних типів у відсортованому порядку, а також додавати та видаляти елементи у списку. Може автоматично збільшувати свій розмір при додаванні нових елементів, що дозволяє не вказувати розмір масиву вручну. Кожен елемент масиву зберігається у вигляді об'єкта, тому ArrayList також дозволяє зберігати дані різних типів, включаючи примітивні типи даних.
* Надає швидкий доступ до елементу по індексу.
* Повільний, коли треба вставити або видалити елемент з середини списку.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**LinkedList** - це клас, що дозволяє зберіганти елементи у зв'язаному списку, де кожен елемент списку зберігає вказівник на наступний елемент у списку. LinkedList складається з вузлів (Node), кожен з яких містить дві властивості: дані та вказівник на наступний вузол. Для доступу до елементів списку потрібно пройти через усі вузли від голови до хвоста. Одна з переваг LinkedList полягає в тому, що він може динамічно змінювати свій розмір, без необхідності копіювати всі елементи у новий масив, як у випадку з ArrayList.

* Дозволяє додавати та видаляти елементи з початку та кінця списку швидше, ніж у випадку з ArrayList, хоча це може бути повільніше, ніж у випадку з доступом до елементів за індексом.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**Vector** є динамічним масивом, подібним до класу ArrayList. Однак, у відміну від ArrayList, Vector є потокобезпечним (англ. thread-safe), тобто може використовуватися у багатопоточних програмах без додаткового синхронізації доступу до елементів.

**Stack** - це клас, який використовується для зберігання та управління елементами в порядку "останнім прийшов - першим вийшов" **(LIFO - Last-In-First-Out)**. Stack утримує колекцію елементів, доступ до яких можливий тільки через один кінець стеку, який називається вершиною (англ. top). Нові елементи додаються та видаляються з вершини. Stack можна реалізувати у вигляді масиву або LinkedList, проте використання LinkedList є більш ефективним, оскільки дозволяє легко додавати та вилучати елементи з початку та кінця списку.

---
## Queue
Інтерфейс **Queue** в Java є частиною **Collection Framework** і визначає контракт для структури даних типу queue. Структура даних queue - це колекція, що працює за принципом "перший ввійшов, перший вийшов" **(англ. first-in, first-out, FIFO)**.

Основні методи, які доступні в інтерфейсі Queue, включають:

* `add(E element)`, або `offer(E element)` - додає елемент в кінець черги
* `remove()`, або `poll()` - вилучає та повертає елемент з початку черги
*  `element()`, або `peek()` - повертає елемент з початку черги без його вилучення
*  `size()` - повертає кількість елементів в черзі
*  `isEmpty()` - перевіряє, чи черга порожня

Інтерфейс Queue є базовим для інших інтерфейсів, які використовують структуру даних черга, наприклад, `Deque` (Double Ended Queue) та `BlockingQueue`. У Java існує кілька реалізацій інтерфейсу Queue, таких як `ArrayDeque`, `LinkedList` та `PriorityQueue`.

---
## Set
**Set** - це інтерфейс, який використовується для зберігання набору унікальних елементів без сортування. В Java існує інтерфейс Set, який включає в себе методи для додавання елементів, вилучення елементів та перевірки наявності елементів у Set. Set використовується там, де необхідно зберігати колекцію унікальних елементів без сортування. Set може бути корисний для пошуку унікальних елементів, фільтрації дублікатів, перетину, об'єднання та різниці між двома колекціями.Для отримання елементів з Set використовується Iterator.

Set може бути реалізований за допомогою різних класів, наприклад, `HashSet`, `TreeSet`, `LinkedHashSet`. 
* `HashSet` - це найбільш швидка реалізація Set, яка забезпечує найкращу продуктивність в порівнянні з іншими реалізаціями. 
* `TreeSet` - це реалізація Set, яка зберігає елементи у відсортованому порядку. 
* `LinkedHashSet` - це реалізація Set, яка зберігає порядок **додавання** елементів.

**SortedSet** - це підінтерфейс інтерфейсу Set у Java, який додає можливість зберігати елементи відсортованими в порядку зростання або спадання. У SortedSet немає дублікатів, але всі елементи зберігаються в відсортованому порядку за допомогою Comparator або Comparable інтерфейсу.

**NavigableSet** - це розширення інтерфейсу `SortedSet` у Java, який надає додаткові методи для навігації по відсортованому множині. NavigableSet дозволяє знаходити найближчий елемент до заданого значення, отримувати підмножину елементів в заданому діапазоні, а також виконувати операції над елементами в порядку зростання або спадання. NavigableSet має ряд методів, які не доступні у SortedSet, такі як `ceiling`, `floor`, `higher`, `lower`, `pollFirs`t, `pollLast`, `descendingSet` та інші.

---
## Map


