# Java Collections Framework

![Java Collections Framework diagram](java-collections-cheat-sheet.png "Java Collections Framework diagram")

---
## List
**List** є одним із основних інтерфейсів для роботи зі списками. List розширює інтерфейс `Collection`, додаючи нові методи, які дозволяють додавати та видаляти елементи за індексом, відстежувати кількість елементів у списку, знаходити індекс елемента, тощо.

* `add(int index, E element)`: додає елемент у заданий індекс у списку
* `remove(int index)`: видаляє елемент за вказаним індексом зі списку
* `get(int index)`: повертає елемент за вказаним індексом
* `set(int index, E element)`: змінює елемент за вказаним індексом
* `indexOf(Object o)`: повертає індекс першого входження елемента в списку

Інтерфейс List може бути реалізований за допомогою різних класів, таких як `ArrayList`, `LinkedList`, `Vector` тощо. 

**ArrayList** - клас, що дозволяє зберігати дані різних типів у відсортованому порядку, а також додавати та видаляти елементи у списку. Може автоматично збільшувати свій розмір при додаванні нових елементів, що дозволяє не вказувати розмір масиву вручну. Кожен елемент масиву зберігається у вигляді об'єкта, тому ArrayList також дозволяє зберігати дані різних типів, включаючи примітивні типи даних.
* Надає швидкий доступ до елементу по індексу.
* Повільний, коли треба вставити або видалити елемент з середини списку.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**LinkedList** - це клас, що дозволяє зберіганти елементи у зв'язаному списку, де кожен елемент списку зберігає вказівник на наступний елемент у списку. LinkedList складається з вузлів (Node), кожен з яких містить дві властивості: дані та вказівник на наступний вузол. Для доступу до елементів списку потрібно пройти через усі вузли від голови до хвоста. Одна з переваг LinkedList полягає в тому, що він може динамічно змінювати свій розмір, без необхідності копіювати всі елементи у новий масив, як у випадку з ArrayList.

* Дозволяє додавати та видаляти елементи з початку та кінця списку швидше, ніж у випадку з ArrayList, хоча це може бути повільніше, ніж у випадку з доступом до елементів за індексом.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**Vector** є динамічним масивом, подібним до класу ArrayList. Однак, у відміну від ArrayList, Vector є потокобезпечним (англ. thread-safe), тобто може використовуватися у багатопоточних програмах без додаткового синхронізації доступу до елементів.

**Stack** - це клас, який використовується для зберігання та управління елементами в порядку "останнім прийшов - першим вийшов" **(LIFO - Last-In-First-Out)**. Stack утримує колекцію елементів, доступ до яких можливий тільки через один кінець стеку, який називається вершиною (англ. top). Нові елементи додаються та видаляються з вершини. Stack можна реалізувати у вигляді масиву або LinkedList, проте використання LinkedList є більш ефективним, оскільки дозволяє легко додавати та вилучати елементи з початку та кінця списку.

---
## Queue
Інтерфейс **Queue** в Java є частиною **Collection Framework** і визначає контракт для структури даних типу queue. Структура даних queue - це колекція, що працює за принципом "перший ввійшов, перший вийшов" **(англ. first-in, first-out, FIFO)**.

Основні методи, які доступні в інтерфейсі Queue, включають:

* `add(E element)`, або `offer(E element)` - додає елемент в кінець черги
* `remove()`, або `poll()` - вилучає та повертає елемент з початку черги
*  `element()`, або `peek()` - повертає елемент з початку черги без його вилучення
*  `size()` - повертає кількість елементів в черзі
*  `isEmpty()` - перевіряє, чи черга порожня

Інтерфейс Queue є базовим для інших інтерфейсів, які використовують структуру даних черга, наприклад, `Deque` (Double Ended Queue) та `BlockingQueue`. У Java існує кілька реалізацій інтерфейсу Queue, таких як `ArrayDeque`, `LinkedList` та `PriorityQueue`.

---
## Set
Інтерфейс **Set** в Java є частиноюCollection Framework і визначає контракт для колекції, що не містить дублікатів елементів. Set можна розглядати як математичну множину, яка не допускає повторення елементів.

Основні методи, які доступні в інтерфейсі Set, включають:

* `add(E element)` - додає елемент в Set, якщо його там ще немає
* `remove(Object o)` - вилучає елемент з Set
* `contains(Object o)` - перевіряє, чи містить Set заданий елемент
* `size()` - повертає кількість елементів в Set
* `isEmpty()` - перевіряє, чи Set порожній
* `iterator()` - повертає ітератор для ітерування елементів Set

Інтерфейс Set є базовим для деяких інших інтерфейсів, які використовують колекції без дублікатів, такі як `SortedSet` та `NavigableSet`. 

**SortedSet** - це підінтерфейс інтерфейсу Set у Java, який додає можливість зберігати елементи відсортованими в порядку зростання або спадання. У SortedSet немає дублікатів, але всі елементи зберігаються в відсортованому порядку за допомогою Comparator або Comparable інтерфейсу.

**NavigableSet** - це розширення інтерфейсу `SortedSet` у Java, який надає додаткові методи для навігації по відсортованому множині. NavigableSet дозволяє знаходити найближчий елемент до заданого значення, отримувати підмножину елементів в заданому діапазоні, а також виконувати операції над елементами в порядку зростання або спадання. NavigableSet має ряд методів, які не доступні у SortedSet, такі як `ceiling`, `floor`, `higher`, `lower`, `pollFirs`t, `pollLast`, `descendingSet` та інші.

У Java існує кілька реалізацій інтерфейсу Set, таких як `HashSet`, `TreeSet`, `LinkedHashSet`.

**HashSet** є найбільш швидкою реалізацією інтерфейсу Set, який забезпечує зберігання колекції елементів без дублікатів в довільному порядку. HashSet забезпечує швидкий доступ до елементів завдяки своїй реалізації на основі хеш-таблиць. HashSet дозволяє додавати значення null, але тільки одне.

**TreeSet** є реалізацією інтерфейсу SortedSet, який забезпечує зберігання колекції елементів без дублікатів у відсортованому порядку. TreeSet забезпечує швидкий доступ до елементів завдяки своїй реалізації на основі дерев. TreeSet не дозволяє додавати значення null.

**LinkedHashSet** є реалізацією інтерфейсу Set, який зберігає колекцію унікальних елементів без дублікатів. Відмінність LinkedHashSet від HashSet полягає у тому, що він зберігає **порядок додавання** елементів в колекцію.

---
## Map


