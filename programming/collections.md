# Java Collections Framework

![Java Collections Framework diagram](/images/java-collections-cheat-sheet.png "Java Collections Framework diagram")

---
## List
**List** є одним із основних інтерфейсів для роботи зі списками. List розширює інтерфейс `Collection`, додаючи нові методи, які дозволяють додавати та видаляти елементи за індексом, відстежувати кількість елементів у списку, знаходити індекс елемента, тощо.

* `add(int index, E element)`: додає елемент у заданий індекс у списку
* `remove(int index)`: видаляє елемент за вказаним індексом зі списку
* `get(int index)`: повертає елемент за вказаним індексом
* `set(int index, E element)`: змінює елемент за вказаним індексом
* `indexOf(Object o)`: повертає індекс першого входження елемента в списку

Інтерфейс List може бути реалізований за допомогою різних класів, таких як `ArrayList`, `LinkedList`, `Vector` тощо. 

**ArrayList** - клас, що дозволяє зберігати дані різних типів у відсортованому порядку, а також додавати та видаляти елементи у списку. Може автоматично збільшувати свій розмір при додаванні нових елементів, що дозволяє не вказувати розмір масиву вручну. Кожен елемент масиву зберігається у вигляді об'єкта, тому ArrayList також дозволяє зберігати дані різних типів, включаючи примітивні типи даних.
* Надає швидкий доступ до елементу по індексу.
* Повільний, коли треба вставити або видалити елемент з середини списку.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**LinkedList** - це клас, що дозволяє зберіганти елементи у зв'язаному списку, де кожен елемент списку зберігає вказівник на наступний елемент у списку. LinkedList складається з вузлів (Node), кожен з яких містить дві властивості: дані та вказівник на наступний вузол. Для доступу до елементів списку потрібно пройти через усі вузли від голови до хвоста. Одна з переваг LinkedList полягає в тому, що він може динамічно змінювати свій розмір, без необхідності копіювати всі елементи у новий масив, як у випадку з ArrayList.

* Дозволяє додавати та видаляти елементи з початку та кінця списку швидше, ніж у випадку з ArrayList, хоча це може бути повільніше, ніж у випадку з доступом до елементів за індексом.
* Дозволяє зберігати будь-які значення в т.ч. null.
* Не синхронізований

**Vector** є динамічним масивом, подібним до класу ArrayList. Однак, у відміну від ArrayList, Vector є потокобезпечним (англ. thread-safe), тобто може використовуватися у багатопоточних програмах без додаткового синхронізації доступу до елементів.

**Stack** - це клас, який використовується для зберігання та управління елементами в порядку "останнім прийшов - першим вийшов" **(LIFO - Last-In-First-Out)**. Stack утримує колекцію елементів, доступ до яких можливий тільки через один кінець стеку, який називається вершиною (англ. top). Нові елементи додаються та видаляються з вершини. Stack можна реалізувати у вигляді масиву або LinkedList, проте використання LinkedList є більш ефективним, оскільки дозволяє легко додавати та вилучати елементи з початку та кінця списку.

---
## Queue
Інтерфейс **Queue** в Java є частиною **Collection Framework** і визначає контракт для структури даних типу queue. Структура даних queue - це колекція, що працює за принципом "перший ввійшов, перший вийшов" **(англ. first-in, first-out, FIFO)**.

Основні методи, які доступні в інтерфейсі Queue, включають:

* `add(E element)`, або `offer(E element)` - додає елемент в кінець черги
* `remove()`, або `poll()` - вилучає та повертає елемент з початку черги
*  `element()`, або `peek()` - повертає елемент з початку черги без його вилучення
*  `size()` - повертає кількість елементів в черзі
*  `isEmpty()` - перевіряє, чи черга порожня

Інтерфейс Queue є базовим для інших інтерфейсів, які використовують структуру даних черга, наприклад, `Deque` (Double Ended Queue) та `BlockingQueue`. У Java існує кілька реалізацій інтерфейсу Queue, таких як `ArrayDeque`, `LinkedList` та `PriorityQueue`.

---
## Set
Інтерфейс **Set** в Java є частиною Collection Framework і визначає контракт для колекції, що не містить дублікатів елементів. Set можна розглядати як математичну множину, яка не допускає повторення елементів.

Основні методи, які доступні в інтерфейсі Set, включають:

* `add(E element)` - додає елемент в Set, якщо його там ще немає
* `remove(Object o)` - вилучає елемент з Set
* `contains(Object o)` - перевіряє, чи містить Set заданий елемент
* `size()` - повертає кількість елементів в Set
* `isEmpty()` - перевіряє, чи Set порожній
* `iterator()` - повертає ітератор для ітерування елементів Set

Інтерфейс Set є базовим для деяких інших інтерфейсів, які використовують колекції без дублікатів, такі як `SortedSet` та `NavigableSet`. 

**SortedSet** - це підінтерфейс інтерфейсу Set у Java, який додає можливість зберігати елементи відсортованими в порядку зростання або спадання. У SortedSet немає дублікатів, але всі елементи зберігаються в відсортованому порядку за допомогою Comparator або Comparable інтерфейсу.

**NavigableSet** - це розширення інтерфейсу `SortedSet` у Java, який надає додаткові методи для навігації по відсортованому множині. NavigableSet дозволяє знаходити найближчий елемент до заданого значення, отримувати підмножину елементів в заданому діапазоні, а також виконувати операції над елементами в порядку зростання або спадання. NavigableSet має ряд методів, які не доступні у SortedSet, такі як `ceiling`, `floor`, `higher`, `lower`, `pollFirs`t, `pollLast`, `descendingSet` та інші.

У Java існує кілька реалізацій інтерфейсу Set, таких як `HashSet`, `TreeSet`, `LinkedHashSet`.

**HashSet** є найбільш швидкою реалізацією інтерфейсу Set, який забезпечує зберігання колекції елементів без дублікатів в довільному порядку. HashSet забезпечує швидкий доступ до елементів завдяки своїй реалізації на основі хеш-таблиць. HashSet дозволяє додавати значення null, але тільки одне.

**TreeSet** є реалізацією інтерфейсу SortedSet, який забезпечує зберігання колекції елементів без дублікатів у відсортованому порядку. TreeSet забезпечує швидкий доступ до елементів завдяки своїй реалізації на основі дерев. TreeSet не дозволяє додавати значення null.

**LinkedHashSet** є реалізацією інтерфейсу Set, який зберігає колекцію унікальних елементів без дублікатів. Відмінність LinkedHashSet від HashSet полягає у тому, що він зберігає **порядок додавання** елементів в колекцію.

---
## Map
**Інтерфейс Map** є частиною Java Collections Framework і представляє собою колекцію пар ключ-значення. Кожне значення в Map може бути доступним за допомогою свого ключа, який є унікальним у межах колекції.

Основні методи, що доступні в інтерфейсі Map, включають:

* `put(key, value)` - додає пару ключ-значення в колекцію Map.
* `get(key)` - повертає значення, що відповідає заданому ключу в колекції Map.
* `remove(key)` - вилучає пару ключ-значення, що відповідає заданому ключу, з колекції Map.
* `containsKey(key)` - перевіряє наявність заданого ключу в колекції Map.
* `containsValue(value)` - перевіряє наявність заданого значення в колекції Map.
* `keySet()` - повертає Set ключів, що містяться в колекції Map.
* `values()` - повертає колекцію значень, що містяться в колекції Map.
* `entrySet()` - повертає Set пар ключ-значення, що містяться в колекції Map.

Інтерфейс Map має кілька реалізацій у Java, таких як `HashMap`, `TreeMap`, `LinkedHashMap` та інші.

**HashMap** є реалізацією інтерфейсу Map, який зберігає дані у хеш-таблиці. Клас HashMap дозволяє швидко здійснювати операції додавання, вилучення та отримання значення. При додаванні елемента до колекції HashMap, його ключ обчислюється за допомогою хеш-функції, що перетворює ключ у числовий індекс, який використовується для зберігання значення в внутрішній хеш-таблиці.

**TreeMap** є реалізацією інтерфейсу Map, який зберігає дані у вигляді ключ-значення у відсортованій колекції.Основна відмінність TreeMap від HashMap полягає у тому, що елементи зберігаються у відсортованому порядку за ключем. Порядок сортування може бути заданий за допомогою порівняння ключів за замовчуванням або власним компаратором, переданим як параметр конструктора.

**LinkedHashMap** є реалізацією інтерфейсу Map, який зберігає пари ключ-значення у впорядкованому вигляді, згідно з порядком їх додавання до мапи. Тобто порядок ітерації через мапу буде такий самий, як порядок, в якому елементи були додані. Клас LinkedHashMap зберігає зв'язки між ключами і значеннями в зв'язаному списку, який зберігає порядок додавання елементів. При додаванні нових елементів в мапу, вони додаються до кінця цього списку. В порівнянні з HashMap, LinkedHashMap має більшу витрату пам'яті, оскільки потребує додаткового простору для зберігання посилань на елементи списку.

---
